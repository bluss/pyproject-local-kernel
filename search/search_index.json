{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyproject Local Jupyter Kernel","text":"<p>  [Website][] - [PyPI][] [![PyPI - Python Version](https://img.shields.io/pypi/v/pyproject-local-kernel)][PyPi]  </p> <p>Separate dependencies for Jupyter notebooks - each notebook project can have its own dependencies!</p> <p>Instead of installing a myriad of Jupyter kernelspecs, one per project, with this solution there is only one kernel provisioner that enables the environment for the project the notebook file resides in. This approach should be more portable, usable to anyone who checks out your project structure from git, and easier to use.</p> <p>Pyproject Local supports Uv, Poetry, Hatch, Rye, and PDM and reads <code>pyproject.toml</code> to figure out which kind of project it is. Or it can use a custom command or a bare virtual environment directly.</p> <p></p>"},{"location":"#quick-start-jupyterlab","title":"Quick Start (JupyterLab)","text":"<ol> <li>Install pyproject-local-kernel in your Jupyterlab environment and restart    Jupyterlab</li> <li>Create a new directory for the notebook project</li> <li>Create a new notebook and select the Pyproject Local kernel</li> <li>In the \u201cfallback\u201d environment that appears - because it is an empty    project - create a new project.</li> </ol> <p>(Example for Uv:)</p> <p><code>!uv init &amp;&amp; uv add ipykernel</code></p> <ol> <li>Use the restart button in JupyterLab to restart the kernel after these changes.</li> <li>Dependencies will quickly sync and you are good to go!</li> <li>Use more <code>add</code> commands to add further dependencies.</li> </ol> <p>See the examples directory for how to setup Jupyterlab and notebook projects separately. JupyterLab and the notebook are installed in separate environments.</p> <p>Do you want to use pyproject-local-kernel in other environments, like with papermill, VSCodium or VS Code, or or other ways? See our FAQ for more information.</p>"},{"location":"#user-experience","title":"User Experience","text":"<p>If started in an empty directory or where a project is not correctly set up, the Pyproject Local will fail to start normally, but it will start a fallback kernel so that you can fix the project.</p> <p>It will show a message like this - with some details about the error.</p> <pre><code>! Error: Could not find `ipykernel` in environment.\n! Add `ipykernel` as a dependency in your project and update the virtual environment.\n! The detected project type is: Unknown\n!\n! This is a fallback - pyproject-local-kernel failed to start.\n! The purpose of the fallback is to let you run shell commands to fix the\n! environment - when you are done, restart the kernel and try again!\n</code></pre> <p>Remember that you can also use Jupyterlab's embedded terminal to help setting up a project.</p> <p>If <code>pyproject.toml</code> is Missing</p> <p>If the Pyproject Local kernel is selected in a project where there is no <code>pyproject.toml</code>, then starting the kernel fails. On first run it should show an error message in JupyterLab.</p> <p>If this happens, create a new <code>pyproject.toml</code> with the editor or use one of the project init commands to create a new project.</p> <p>If the <code>ipykernel</code> is Missing</p> <p>The notebook project needs to install <code>ipykernel</code> as a dependency.</p> <p>Edit the <code>pyproject.toml</code> to include <code>ipykernel</code> in dependencies:</p> <pre><code>dependencies = [\n    \"ipykernel&gt;=6.29\",\n    # .. more dependencies\n]\n</code></pre> <p>sync the changes to the project using sync command for the project manager you use, then restart the Pyproject local kernel in Jupyterlab.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>Configuration is optional and is read from <code>pyproject.toml</code>. Only the <code>pyproject.toml</code> closest to the notebook is read. Defaults are based on \u201csniffing\u201d the <code>pyproject.toml</code> to detect which project manager is in use.</p>"},{"location":"#python-cmd","title":"<code>python-cmd</code>","text":"<p>The key <code>tool.pyproject-local-kernel.python-cmd</code> should be a command that runs python from the environment you want to use for the project.</p> <p>If this is set then it overrides the default command. There is further explanation in the FAQ.</p> <p>Default: Depends on project manager Type: <code>list[str] | str</code> Example:</p> <pre><code>[tool.pyproject-local-kernel]\npython-cmd = [\"uv\", \"run\", \"--with\", \"ipykernel\", \"python\"]\n</code></pre>"},{"location":"#use-venv","title":"<code>use-venv</code>","text":"<p>Path to virtual environment that should be used, relative to the <code>pyproject.toml</code> file. Can also be an absolute path.</p> <p>If this is set then it overrides the default command - the virtualenv is used directly without invoking any project manager. Remember to explicitly install or sync required dependencies.</p> <p>Default: Not set Type: <code>str</code> Example:</p> <pre><code>[tool.pyproject-local-kernel]\nuse-venv = \".venv\"\n</code></pre>"},{"location":"#sanity-check","title":"<code>sanity-check</code>","text":"<p>If <code>true</code>, then run a check for <code>ipykernel</code> being installed in the project before starting the kernel process.</p> <p>Default: true Type: <code>bool</code> Example:</p> <pre><code>[tool.pyproject-local-kernel]\nsanity-check = true\n</code></pre>"},{"location":"#pyprojectkernelprovisioner","title":"<code>PyprojectKernelProvisioner</code>","text":"<p>The kernel provisioner is configurable in the same way as other Jupyter objects, with the following settings. They can be set in your <code>jupyter_lab_config.py</code> settings file. When possible, prefer to use settings in <code>pyproject.toml</code> instead, to keep them close to the project.</p> <pre><code>#------------------------------------------------------------------------------\n# PyprojectKernelProvisioner(LocalProvisioner) configuration\n#------------------------------------------------------------------------------\n## Enable sanity check for 'ipykernel' package in environment\n#  Default: True\n# c.PyprojectKernelProvisioner.sanity_check = True\n\n## Default setting for use-venv for projects using the 'use-venv' kernel\n#  Default: '.venv'\n# c.PyprojectKernelProvisioner.use_venv = '.venv'\n</code></pre>"},{"location":"#about-particular-project-managers","title":"About Particular Project Managers","text":"<p>The project manager command, be it rye, uv, pdm, etc needs to be available on the path where Jupyterlab runs. Either install the project manager in the Jupyterlab environment, or install the project manager user-wide (using something like pipx, uv tool, rye tools, brew, or other method to install it.)</p> <p>Uv</p> <ul> <li> <p>Uv is detected if the pyproject.toml contains <code>tool.uv</code>. It is also the   default fallback if no project manager is detected from a pyproject file.</p> </li> <li> <p>The command used is <code>uv run --with ipykernel python</code> which means that it ensures   <code>ipykernel</code> is used even if it's not already in the project(!). However, note that   it uses an ephemeral virtual environment for ipykernel in that case.   Add ipykernel to the project to avoid this.</p> </li> </ul> <p>Rye</p> <ul> <li>Rye is detected if the pyproject.toml contains <code>tool.rye.managed = true</code>   which Rye sets by default for its new projects.</li> </ul> <p>PDM</p> <ul> <li>PDM is detected if pyproject.toml contains <code>tool.pdm</code></li> </ul> <p>Hatch</p> <ul> <li> <p>Hatch is detected if pyproject.toml contains <code>tool.hatch.envs</code></p> </li> <li> <p>By default it calls out to <code>hatch env find</code>, to find the default virtualenv,   and runs from there. <code>hatch run</code> should not be used directly because   it's not compatible with how kernel interrupts work (as of this writing).</p> </li> <li> <p>It's best to create the hatch project, add ipykernel as dependency and sync   dependencies in a terminal before starting (it does not work so well with   shell commands in a notebook).</p> </li> </ul> <p>Poetry</p> <ul> <li> <p>Poetry is detected if pyproject.toml contains <code>tool.poetry.name</code></p> </li> <li> <p>Some commands are interactive by default and don't work in a notebook,   but they have an <code>-n</code> switch to make them non-interactive.</p> </li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Additional interest and maintainer help is welcomed.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>https://github.com/astral-sh/uv</li> <li>https://github.com/renan-r-santos/pixi-kernel</li> <li>https://github.com/goerz/python-localvenv-kernel</li> <li>https://github.com/pathbird/poetry-kernel</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>pyproject-local-kernel</code> is open source. See the LICENSE.md file in the source distribution for more information.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#0121","title":"0.12.1","text":"<ul> <li> <p>Update how configuration types are displayed in errors (#60)</p> </li> <li> <p>Pin Python 3.12 for the examples (#62)</p> </li> <li> <p>Minor fixes to fallback kernel mode (#62)</p> </li> <li> <p>Clarify error message when project section is missing from <code>pyproject.toml</code>   (#62)</p> </li> </ul>"},{"location":"CHANGELOG/#0120","title":"0.12.0","text":"<ul> <li> <p>Show more specific error if we fail to run sanity check (#55)</p> </li> <li> <p>Add project config <code>sanity-check</code> (#55)</p> </li> <li> <p>Accept both underscore and hyphen in project configuration (#55)</p> </li> <li> <p>Sharpen the public/private API distinction even if this is not a library;   only the main function and the kernel provisioner are public API now. (#57)</p> </li> </ul>"},{"location":"CHANGELOG/#0113","title":"0.11.3","text":"<ul> <li> <p>Set <code>PYPROJECT_LOCAL_KERNEL_SANITY_CHECK</code> in the environment when running the   sanity check. (#51)</p> </li> <li> <p>Log working directory setting when starting kernel process. (#51)</p> </li> <li> <p>If <code>pyproject.toml</code> has no project section, do not identify it as belonging   to a project manager that requires the project section. (#52)</p> </li> </ul>"},{"location":"CHANGELOG/#0112","title":"0.11.2","text":"<ul> <li> <p>Enable the binary path in the virtual environment for use-venv   and hatch configurations (#48)</p> </li> <li> <p>Launch fallback kernel using <code>python -m</code>. (#49)</p> </li> <li> <p>Test using Python 3.13. (#45)</p> </li> </ul>"},{"location":"CHANGELOG/#0111","title":"0.11.1","text":"<ul> <li> <p>Add another kernelspec Pyproject Local (use-venv) which defaults to the   <code>use-venv</code> setting, using the virtual environment directly.   (#43 and cb90a20).</p> </li> <li> <p><code>PyprojectKernelProvisioner</code> is now configurable like other \u201cjupyter objects\u201d   using the same config system. However, <code>pyproject.toml</code> configuration   should be preferred. (#43)</p> </li> <li> <p>When preparing to start the kernel, only errors from known checks   are caught and passed off to the starting fallback kernel.   (aaed1da)</p> </li> </ul>"},{"location":"CHANGELOG/#0110","title":"0.11.0","text":"<ul> <li>Use local kernel provisioning to launch the kernel. This is   a more standard way to do it, with less overhead and less compatibility   issues. (#39)</li> <li>Improved fallback mode on errors and documentation around this</li> <li>License update again, more or less reverting what was done in v0.10.0,   because the relevant code has been removed. (#39)</li> <li>The package now installs an executable <code>pyproject_local_kernel</code> that is   used interally (#39)</li> <li>This one goes to eleven, it really does</li> </ul>"},{"location":"CHANGELOG/#0101","title":"0.10.1","text":"<ul> <li>If there is no <code>pyproject.toml</code> at all, show an error message to the user   instead of throwing an exception. Fixes a regression. (#34)</li> <li>Fix running tests in sdist (#33)</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>Support interrupting the kernel on windows (#30, #32)</li> <li>Now uses <code>jupyter-client</code> to launch the kernel process (#30)</li> <li>License was updated after we copied one file from ipykernel,   now a combination of MIT and BSD 3-clause.</li> </ul>"},{"location":"CHANGELOG/#091","title":"0.9.1","text":"<ul> <li>Call <code>hatch env find</code> using <code>--no-color</code> for robustness (#27)</li> <li>Support a command string for <code>python-cmd</code> configuration (#28)</li> <li>Better test setup for jupyter using pytest (#27)</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":"<ul> <li>Check configuration value types strictly and warn on unknown configuration</li> <li>Examples in the repository now use Uv</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>Fix problem trying to forward SIGCHLD to kernel, which was maybe specific to   Python 3.8 (and not-windows) (#24)</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>Change how <code>hatch</code> projects are run: detect the (default) virtual env path   and run python from there. User has to ensure virtualenv dependencies are   synchronized. (#23)</li> </ul>"},{"location":"CHANGELOG/#072","title":"0.7.2","text":"<ul> <li>Published documentation to a new website using mkdocs</li> <li>Copyedited documentation</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>Use Uv as first fallback if no explicit project manager can be identified   from the pyproject if <code>uv</code> is in the command path. Use Rye as the second   fallback in the same way.</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>Use <code>uv run</code> for uv projects. Requires uv 0.2.29 or later.   Uses <code>uv run --with ipykernel</code> which means it will run as   before if ipykernel is already installed, or run in an overlay   environment (ipykernel + base pyproject) if not.</li> <li>Include kernel start failure messages in user visible text in more cases such   as \u201ccommand not found\u201d.</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>Support configuration <code>use-venv</code> for setting a name of a virtualenv to use</li> <li>Support Uv (in a basic way, by assuming <code>use-venv=\".venv\"</code> for uv)</li> </ul>"},{"location":"CHANGELOG/#055","title":"0.5.5","text":"<ul> <li>Fix ProjectDetection.path which should hold the path to the pyproject file</li> <li>Added trusted publishing (for PyPI) workflow on github</li> </ul>"},{"location":"CHANGELOG/#054","title":"0.5.4","text":"<ul> <li>Enable debugging for the Pyproject Local kernel (just like the regular ipykernel)</li> <li>More extensive tests, on linux and windows, including notebook execution</li> </ul>"},{"location":"CHANGELOG/#053","title":"0.5.3","text":"<ul> <li>Add tests. Moved main logic to module to facilitate.</li> <li>Update readme</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>Use tomllib for newer Python, and tomli as fallback</li> <li>Catch all exceptions when starting the kernel, so that the fallback can be started in most situations.</li> <li>More detailed error messages in the fallback</li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>Cleaned up unnecessary log output</li> <li>Set repo URL in package</li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":"<ul> <li>Changed name to pyproject-local-kernel (previously ryeish-kernel)</li> <li>Now supports Rye, PDM, Poetry, Hatch and custom configuration</li> </ul>"},{"location":"FAQ/","title":"Frequently Asked Questions","text":""},{"location":"FAQ/#how-does-it-work","title":"How does it work?","text":"<p>The regular IPython kernel for Jupyter is launched like this: <code>python -m ipykernel_launcher -f &lt;connection_file&gt;</code></p> <p>If you just prefix that command with <code>rye run</code>, <code>uv run</code>, <code>poetry run</code>, <code>pdm run</code>, <code>hatch run</code>, etc, then you get a kernel invocation that executes in the current pyproject's environment. That's basically the whole magic of this package, it doesn't need to do more (well, if it only were that easy..)</p> <p>It uses Kernel Provisioning in <code>jupyter-client</code> to launch the right command depending on project configuration.</p>"},{"location":"FAQ/#how-do-i-install-it","title":"How do I install it?","text":"<p>To break it down:</p> <ul> <li>You install <code>jupyterlab</code> and <code>pyproject-local-kernel</code> together.</li> <li>Then you have projects defined by <code>pyproject.toml</code> for each notebook   or collection of notebooks. They install <code>ipykernel</code> and packages   you want to use in the notebook.</li> </ul> <p>See also <code>example/</code> in the git repository.</p>"},{"location":"FAQ/#why-do-i-have-to-install-ipykernel-manually","title":"Why do I have to install <code>ipykernel</code> manually?","text":"<p>The IPython kernel is the interpreter that executes everything in the notebook, and it needs to be installed together with all the dependencies the notebook wants to import. However only one installation of JupyterLab (or equivalent notebook program) is necessary, and should be separate from the notebook.</p> <p>For Uv, the default command is <code>uv run --with ipykernel</code> which creates an overlay environment containing ipykernel if it wasn't already installed. This makes it possible to skip ipykernel in the project dependencies if desired.</p>"},{"location":"FAQ/#how-can-i-see-which-python-environment-i-am-using","title":"How can I see which Python environment I am using?","text":"<p>In general it is a good idea to look at these variables in a notebook to understand which Python version and Python environment it is using:</p> <pre><code>sys.prefix\nsys.executable\nsys.path\nsys.version_info\n</code></pre> <p>You can also start JupyterLab with debug logs, and look for <code>pyproject-local-kernel</code> debug info in the output.</p>"},{"location":"FAQ/#what-is-the-benefit-of-the-use-venv-setting","title":"What is the benefit of the <code>use-venv</code> setting?","text":"<p>It is used for more flexibility. It means that pyproject local does not depend on any particular project manager and can use any virtual environment.</p> <p>And, if you for example compare the uv default configuration vs a <code>use-venv</code> configuration, both in a uv-defined project, then they stack up like this:</p> <p>Uv default</p> <ul> <li>Runs <code>uv run --with ipykernel python</code></li> <li>Installs <code>ipykernel</code> automatically</li> <li>Syncs dependencies automatically on every start/restart</li> </ul> <p><code>use-venv = \".venv\"</code></p> <ul> <li>Runs <code>python</code> from the virtual environment directly which has less   indirection and overhead</li> <li>Does not create or change the environment, only uses it as it is</li> <li>Requires <code>ipykernel</code> to be installed</li> </ul>"},{"location":"FAQ/#does-pyproject-local-kernel-work-with-nbconvert-and-papermill","title":"Does Pyproject Local Kernel work with Nbconvert and Papermill?","text":"<p>Yes it works, with both Nbconvert and Papermill.</p> <p>Pyproject Local Kernel relies on Jupyter's working directory convention: the working directory is always the same as the notebook's location - and it will work as long as you run Papermill the same way, using its <code>--cwd</code> argument.</p> <p>You can install Papermill and pyproject-local-kernel in a separate environment, and run each notebook in its own pyproject environment with its dependencies this way.</p>"},{"location":"FAQ/#does-it-work-with-conda","title":"Does it work with Conda?","text":"<p>Conda environments are supported only by using the <code>use-venv</code> setting in <code>pyproject.toml</code>, where it needs to point to the location of the installed environment as an absolute path, or a path relative to the the <code>pyproject.toml</code> file.</p> <pre><code>[tool.pyproject-local-kernel]\nuse-venv = \".venv\"\n</code></pre>"},{"location":"FAQ/#how-to-setup-for-vscodium-or-vs-code","title":"How to setup for VSCodium or VS Code?","text":"<p>Note that code natively supports using virtual environments in a local directory directly. For this reason <code>pyproject-local-kernel</code> is almost always unecessary with VSCodium or VS Code (\"code\").</p> <p>Code does not launch the kernel in the same way that Jupyterlab does (Jupyterlab uses <code>jupyter-client</code> and enables kernel provisioning), for this reason <code>pyproject-local-kernel</code> is launched using a less reliable way when using code, and this is a - for now - unsupported way to use this project.</p> <p>However, it should more or less work. Here are some suggestions:</p> <p>Install both <code>jupyter</code> and <code>pyproject-local-kernel</code> in a central Python environment that you choose. (The vscode-jupyter extension instructs that you should install <code>jupyter</code> and tell it where this installation is).</p> <p>Then you need need to use the command Python: Select Interpreter to select the environment where you installed <code>jupyter</code>.</p> <p>When this is done, you can use Select Kernel \u2192 Jupyter Kernel \u2192 Pyproject Local to use this project from code.</p> <p>The output panel has a Jupyter section with logs from the Jupyter kernel, which can help in debugging.</p>"},{"location":"FAQ/#does-it-work-with-with-pipenv","title":"Does it work with with Pipenv?","text":"<ol> <li>Add ipykernel to the environment packages</li> <li>Configure the Python run command in local pyproject file</li> </ol> <pre><code>[tool.pyproject-local-kernel]\npython-cmd = [\"env\", \"PIPENV_IGNORE_VIRTUALENVS=1\", \"pipenv\", \"run\", \"python\"]\n</code></pre>"},{"location":"FAQ/#does-pyproject-local-kernel-require-uv-or-rye","title":"Does Pyproject Local Kernel require Uv or Rye?","text":"<p>No, neither of them are strictly required to use. Any supported project manager is enough, or even none for custom or vitualenv configurations.</p> <p>For development of the project and running tests, Uv is required.</p>"},{"location":"FAQ/#how-does-the-python-cmd-configuration-work","title":"How does the <code>python-cmd</code> configuration work?","text":"<p><code>python-cmd</code> should be a command-line that runs Python, in the environment that should be used for the notebook.</p> <p>For example, for a regular virtual environment, the python command would be <code>.venv/bin/python</code> or <code>.venv\\Scripts\\python.exe</code>.</p> <p>The python command should take arguments and will be run with arguments to start the IPython kernel. It can also be used with different arguments to run a sanity check script, checking if <code>ipykernel</code> is installed. <sup>1</sup></p> <p>Example 1: <code>python-cmd</code> is a script in the same directory as <code>pyproject.toml</code> and when invoked with arguments, it will run python in the desired environment.</p> <pre><code>[tool.pyproject-local-kernel]\npython-cmd = \"./runpy\"\n</code></pre> <p>Example 2: a shell is invoked to be able to use shell constructs like <code>&amp;&amp;</code> directly, and care is taken so that it still uses the extra command line arguments. Of course, using any such script is less portable than just using a project or virtual environment configuration directly.</p> <pre><code>[tool.pyproject-local-kernel]\npython-cmd = [\"bash\", \"-c\", 'uv sync &amp;&amp; X=1 .venv/bin/python -I \"$@\" &amp;&amp; echo done', \"--\"]\n</code></pre>"},{"location":"FAQ/#isnt-there-a-less-complicated-way-to-do-it","title":"Isn't There a Less Complicated Way to Do It?","text":"<p>Yes, there kind of is a way.</p> <p>If you install the following kernelspec, you can use <code>uv run</code> as the environment manager for your notebooks. You don't hardcode a virtual environment path, but you hardcode that you're using <code>uv run</code>.</p> <p>This example does more or less the same as what <code>pyproject-local-kernel</code> does, but without the error handling and configurability:</p> <pre><code>{\n  \"argv\": [\"uv\", \"run\", \"--with\", \"ipykernel\", \"python\", \"-m\", \"ipykernel_launcher\", \"-f\", \"{connection_file}\"],\n  \"display_name\": \"Uv Run Ipykernel\",\n  \"language\": \"python\",\n  \"metadata\": {\n    \"debugger\": true\n  }\n}\n</code></pre> <p>If you have such a <code>.json</code> file, <code>jupyter kernelspec install --user</code> can help you install it.</p>"},{"location":"FAQ/#more-questions-about-uv","title":"More questions about Uv","text":""},{"location":"FAQ/#can-i-start-pyproject-local-kernel-with-uvx","title":"Can I start <code>pyproject-local-kernel</code> with <code>uvx</code>?","text":"<p>Yes, you can launch a full Jupyterlab environment using:</p> <pre><code>uvx --with pyproject-local-kernel --from jupyterlab jupyter-lab\n</code></pre> <p>However it is often good to use a project or environment manager to define the Jupyter environment with your chosen dependencies, so that you can use a lock file and have other benefits of a proper project.</p>"},{"location":"FAQ/#can-i-use-a-different-version-of-python-for-the-notebook","title":"Can I use a different version of Python for the notebook?","text":"<p>Yes, the Python version can be pinned separately per notebook project. It doesn't need to be the same as the Jupyterlab Python version.</p>"},{"location":"FAQ/#why-is-the-python-environment-path-weird","title":"Why is the Python environment path weird?","text":"<p>If you look at <code>sys.prefix</code> when using uv and pyproject local kernel, and you see a prefix like this or similar: <code>'~/.cache/uv/archive-v0/n2G3HHDzRZ7cjiFgGXIwC'</code>, then <code>uv run</code> is using an ephemeral environment to run the kernel. It should work just fine in most cases, but it means that <code>ipykernel</code> is not installed in your base environment. If you want to fix this, use <code>uv add ipykernel</code> and restart the kernel.</p>"},{"location":"FAQ/#can-i-nest-projects","title":"Can I nest projects?","text":"<p>You can, but <code>pyproject-local-kernel</code> always looks at the closest <code>pyproject.toml</code> only, not at the whole workspace.</p> <p>If you want to \u201cisolate\u201d a <code>pyproject.toml</code> insert an empty <code>[tool.uv.workspace]</code> in the <code>pyproject.toml</code>, that way it is not part of any other workspace from directories above it.</p> <ol> <li> <p>The variable <code>PYPROJECT_LOCAL_KERNEL_SANITY_CHECK</code> is set in the environment when running the sanity check.\u00a0\u21a9</p> </li> </ol>"}]}